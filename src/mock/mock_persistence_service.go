// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"anymind"
	"context"
	"sync"
)

// Ensure, that PersistenceServiceMock does implement anymind.PersistenceService.
// If this is not the case, regenerate this file with moq.
var _ anymind.PersistenceService = &PersistenceServiceMock{}

// PersistenceServiceMock is a mock implementation of anymind.PersistenceService.
//
//	func TestSomethingThatUsesPersistenceService(t *testing.T) {
//
//		// make and configure a mocked anymind.PersistenceService
//		mockedPersistenceService := &PersistenceServiceMock{
//			DepositFunc: func(ctx context.Context, input *anymind.DepositInput) error {
//				panic("mock out the Deposit method")
//			},
//			HistoricalFunc: func(ctx context.Context, req *anymind.HistoricalDataReq) ([]*anymind.HistoricalData, error) {
//				panic("mock out the Historical method")
//			},
//		}
//
//		// use mockedPersistenceService in code that requires anymind.PersistenceService
//		// and then make assertions.
//
//	}
type PersistenceServiceMock struct {
	// DepositFunc mocks the Deposit method.
	DepositFunc func(ctx context.Context, input *anymind.DepositInput) error

	// HistoricalFunc mocks the Historical method.
	HistoricalFunc func(ctx context.Context, req *anymind.HistoricalDataReq) ([]*anymind.HistoricalData, error)

	// calls tracks calls to the methods.
	calls struct {
		// Deposit holds details about calls to the Deposit method.
		Deposit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input *anymind.DepositInput
		}
		// Historical holds details about calls to the Historical method.
		Historical []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *anymind.HistoricalDataReq
		}
	}
	lockDeposit    sync.RWMutex
	lockHistorical sync.RWMutex
}

// Deposit calls DepositFunc.
func (mock *PersistenceServiceMock) Deposit(ctx context.Context, input *anymind.DepositInput) error {
	if mock.DepositFunc == nil {
		panic("PersistenceServiceMock.DepositFunc: method is nil but PersistenceService.Deposit was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input *anymind.DepositInput
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockDeposit.Lock()
	mock.calls.Deposit = append(mock.calls.Deposit, callInfo)
	mock.lockDeposit.Unlock()
	return mock.DepositFunc(ctx, input)
}

// DepositCalls gets all the calls that were made to Deposit.
// Check the length with:
//
//	len(mockedPersistenceService.DepositCalls())
func (mock *PersistenceServiceMock) DepositCalls() []struct {
	Ctx   context.Context
	Input *anymind.DepositInput
} {
	var calls []struct {
		Ctx   context.Context
		Input *anymind.DepositInput
	}
	mock.lockDeposit.RLock()
	calls = mock.calls.Deposit
	mock.lockDeposit.RUnlock()
	return calls
}

// Historical calls HistoricalFunc.
func (mock *PersistenceServiceMock) Historical(ctx context.Context, req *anymind.HistoricalDataReq) ([]*anymind.HistoricalData, error) {
	if mock.HistoricalFunc == nil {
		panic("PersistenceServiceMock.HistoricalFunc: method is nil but PersistenceService.Historical was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *anymind.HistoricalDataReq
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockHistorical.Lock()
	mock.calls.Historical = append(mock.calls.Historical, callInfo)
	mock.lockHistorical.Unlock()
	return mock.HistoricalFunc(ctx, req)
}

// HistoricalCalls gets all the calls that were made to Historical.
// Check the length with:
//
//	len(mockedPersistenceService.HistoricalCalls())
func (mock *PersistenceServiceMock) HistoricalCalls() []struct {
	Ctx context.Context
	Req *anymind.HistoricalDataReq
} {
	var calls []struct {
		Ctx context.Context
		Req *anymind.HistoricalDataReq
	}
	mock.lockHistorical.RLock()
	calls = mock.calls.Historical
	mock.lockHistorical.RUnlock()
	return calls
}
